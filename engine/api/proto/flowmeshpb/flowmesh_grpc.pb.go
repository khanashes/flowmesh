// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v5.29.3
// source: flowmesh.proto

package flowmeshpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	HealthService_HealthCheck_FullMethodName    = "/flowmesh.v1.HealthService/HealthCheck"
	HealthService_ReadinessCheck_FullMethodName = "/flowmesh.v1.HealthService/ReadinessCheck"
)

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// HealthService provides health and readiness checks
type HealthServiceClient interface {
	// HealthCheck checks if the server is running
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// ReadinessCheck checks if the server is ready to serve requests
	ReadinessCheck(ctx context.Context, in *ReadinessCheckRequest, opts ...grpc.CallOption) (*ReadinessCheckResponse, error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, HealthService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthServiceClient) ReadinessCheck(ctx context.Context, in *ReadinessCheckRequest, opts ...grpc.CallOption) (*ReadinessCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadinessCheckResponse)
	err := c.cc.Invoke(ctx, HealthService_ReadinessCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility.
//
// HealthService provides health and readiness checks
type HealthServiceServer interface {
	// HealthCheck checks if the server is running
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	// ReadinessCheck checks if the server is ready to serve requests
	ReadinessCheck(context.Context, *ReadinessCheckRequest) (*ReadinessCheckResponse, error)
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthServiceServer struct{}

func (UnimplementedHealthServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedHealthServiceServer) ReadinessCheck(context.Context, *ReadinessCheckRequest) (*ReadinessCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadinessCheck not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}
func (UnimplementedHealthServiceServer) testEmbeddedByValue()                       {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	// If the following call panics, it indicates UnimplementedHealthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthService_ReadinessCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadinessCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).ReadinessCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_ReadinessCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).ReadinessCheck(ctx, req.(*ReadinessCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "flowmesh.v1.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _HealthService_HealthCheck_Handler,
		},
		{
			MethodName: "ReadinessCheck",
			Handler:    _HealthService_ReadinessCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "flowmesh.proto",
}

const (
	StreamService_WriteEvents_FullMethodName           = "/flowmesh.v1.StreamService/WriteEvents"
	StreamService_ReadStream_FullMethodName            = "/flowmesh.v1.StreamService/ReadStream"
	StreamService_Subscribe_FullMethodName             = "/flowmesh.v1.StreamService/Subscribe"
	StreamService_CommitOffset_FullMethodName          = "/flowmesh.v1.StreamService/CommitOffset"
	StreamService_GetOffset_FullMethodName             = "/flowmesh.v1.StreamService/GetOffset"
	StreamService_GetLatestOffset_FullMethodName       = "/flowmesh.v1.StreamService/GetLatestOffset"
	StreamService_GetConsumerGroupState_FullMethodName = "/flowmesh.v1.StreamService/GetConsumerGroupState"
)

// StreamServiceClient is the client API for StreamService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// StreamService provides operations for working with streams
type StreamServiceClient interface {
	// WriteEvents writes multiple events to a stream and returns assigned offsets
	WriteEvents(ctx context.Context, in *WriteEventsRequest, opts ...grpc.CallOption) (*WriteEventsResponse, error)
	// ReadStream reads messages from a stream starting at a specific offset
	ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (*ReadStreamResponse, error)
	// Subscribe subscribes to a stream with consumer group support (server-side streaming)
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SubscribeResponse], error)
	// CommitOffset commits an offset for a consumer group
	CommitOffset(ctx context.Context, in *CommitOffsetRequest, opts ...grpc.CallOption) (*CommitOffsetResponse, error)
	// GetOffset retrieves the committed offset for a consumer group
	GetOffset(ctx context.Context, in *GetOffsetRequest, opts ...grpc.CallOption) (*GetOffsetResponse, error)
	// GetLatestOffset retrieves the latest offset for a stream partition
	GetLatestOffset(ctx context.Context, in *GetLatestOffsetRequest, opts ...grpc.CallOption) (*GetLatestOffsetResponse, error)
	// GetConsumerGroupState retrieves the complete state of a consumer group including lag
	GetConsumerGroupState(ctx context.Context, in *GetConsumerGroupStateRequest, opts ...grpc.CallOption) (*GetConsumerGroupStateResponse, error)
}

type streamServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamServiceClient(cc grpc.ClientConnInterface) StreamServiceClient {
	return &streamServiceClient{cc}
}

func (c *streamServiceClient) WriteEvents(ctx context.Context, in *WriteEventsRequest, opts ...grpc.CallOption) (*WriteEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteEventsResponse)
	err := c.cc.Invoke(ctx, StreamService_WriteEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) ReadStream(ctx context.Context, in *ReadStreamRequest, opts ...grpc.CallOption) (*ReadStreamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadStreamResponse)
	err := c.cc.Invoke(ctx, StreamService_ReadStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SubscribeResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StreamService_ServiceDesc.Streams[0], StreamService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, SubscribeResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StreamService_SubscribeClient = grpc.ServerStreamingClient[SubscribeResponse]

func (c *streamServiceClient) CommitOffset(ctx context.Context, in *CommitOffsetRequest, opts ...grpc.CallOption) (*CommitOffsetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommitOffsetResponse)
	err := c.cc.Invoke(ctx, StreamService_CommitOffset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) GetOffset(ctx context.Context, in *GetOffsetRequest, opts ...grpc.CallOption) (*GetOffsetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOffsetResponse)
	err := c.cc.Invoke(ctx, StreamService_GetOffset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) GetLatestOffset(ctx context.Context, in *GetLatestOffsetRequest, opts ...grpc.CallOption) (*GetLatestOffsetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLatestOffsetResponse)
	err := c.cc.Invoke(ctx, StreamService_GetLatestOffset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamServiceClient) GetConsumerGroupState(ctx context.Context, in *GetConsumerGroupStateRequest, opts ...grpc.CallOption) (*GetConsumerGroupStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConsumerGroupStateResponse)
	err := c.cc.Invoke(ctx, StreamService_GetConsumerGroupState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StreamServiceServer is the server API for StreamService service.
// All implementations must embed UnimplementedStreamServiceServer
// for forward compatibility.
//
// StreamService provides operations for working with streams
type StreamServiceServer interface {
	// WriteEvents writes multiple events to a stream and returns assigned offsets
	WriteEvents(context.Context, *WriteEventsRequest) (*WriteEventsResponse, error)
	// ReadStream reads messages from a stream starting at a specific offset
	ReadStream(context.Context, *ReadStreamRequest) (*ReadStreamResponse, error)
	// Subscribe subscribes to a stream with consumer group support (server-side streaming)
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[SubscribeResponse]) error
	// CommitOffset commits an offset for a consumer group
	CommitOffset(context.Context, *CommitOffsetRequest) (*CommitOffsetResponse, error)
	// GetOffset retrieves the committed offset for a consumer group
	GetOffset(context.Context, *GetOffsetRequest) (*GetOffsetResponse, error)
	// GetLatestOffset retrieves the latest offset for a stream partition
	GetLatestOffset(context.Context, *GetLatestOffsetRequest) (*GetLatestOffsetResponse, error)
	// GetConsumerGroupState retrieves the complete state of a consumer group including lag
	GetConsumerGroupState(context.Context, *GetConsumerGroupStateRequest) (*GetConsumerGroupStateResponse, error)
	mustEmbedUnimplementedStreamServiceServer()
}

// UnimplementedStreamServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStreamServiceServer struct{}

func (UnimplementedStreamServiceServer) WriteEvents(context.Context, *WriteEventsRequest) (*WriteEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteEvents not implemented")
}
func (UnimplementedStreamServiceServer) ReadStream(context.Context, *ReadStreamRequest) (*ReadStreamResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadStream not implemented")
}
func (UnimplementedStreamServiceServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[SubscribeResponse]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedStreamServiceServer) CommitOffset(context.Context, *CommitOffsetRequest) (*CommitOffsetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CommitOffset not implemented")
}
func (UnimplementedStreamServiceServer) GetOffset(context.Context, *GetOffsetRequest) (*GetOffsetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOffset not implemented")
}
func (UnimplementedStreamServiceServer) GetLatestOffset(context.Context, *GetLatestOffsetRequest) (*GetLatestOffsetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLatestOffset not implemented")
}
func (UnimplementedStreamServiceServer) GetConsumerGroupState(context.Context, *GetConsumerGroupStateRequest) (*GetConsumerGroupStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConsumerGroupState not implemented")
}
func (UnimplementedStreamServiceServer) mustEmbedUnimplementedStreamServiceServer() {}
func (UnimplementedStreamServiceServer) testEmbeddedByValue()                       {}

// UnsafeStreamServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamServiceServer will
// result in compilation errors.
type UnsafeStreamServiceServer interface {
	mustEmbedUnimplementedStreamServiceServer()
}

func RegisterStreamServiceServer(s grpc.ServiceRegistrar, srv StreamServiceServer) {
	// If the following call panics, it indicates UnimplementedStreamServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StreamService_ServiceDesc, srv)
}

func _StreamService_WriteEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).WriteEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_WriteEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).WriteEvents(ctx, req.(*WriteEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_ReadStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).ReadStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_ReadStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).ReadStream(ctx, req.(*ReadStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamServiceServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, SubscribeResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StreamService_SubscribeServer = grpc.ServerStreamingServer[SubscribeResponse]

func _StreamService_CommitOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).CommitOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_CommitOffset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).CommitOffset(ctx, req.(*CommitOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_GetOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).GetOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_GetOffset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).GetOffset(ctx, req.(*GetOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_GetLatestOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestOffsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).GetLatestOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_GetLatestOffset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).GetLatestOffset(ctx, req.(*GetLatestOffsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamService_GetConsumerGroupState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsumerGroupStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamServiceServer).GetConsumerGroupState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StreamService_GetConsumerGroupState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamServiceServer).GetConsumerGroupState(ctx, req.(*GetConsumerGroupStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StreamService_ServiceDesc is the grpc.ServiceDesc for StreamService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "flowmesh.v1.StreamService",
	HandlerType: (*StreamServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WriteEvents",
			Handler:    _StreamService_WriteEvents_Handler,
		},
		{
			MethodName: "ReadStream",
			Handler:    _StreamService_ReadStream_Handler,
		},
		{
			MethodName: "CommitOffset",
			Handler:    _StreamService_CommitOffset_Handler,
		},
		{
			MethodName: "GetOffset",
			Handler:    _StreamService_GetOffset_Handler,
		},
		{
			MethodName: "GetLatestOffset",
			Handler:    _StreamService_GetLatestOffset_Handler,
		},
		{
			MethodName: "GetConsumerGroupState",
			Handler:    _StreamService_GetConsumerGroupState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _StreamService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "flowmesh.proto",
}

const (
	QueueService_Enqueue_FullMethodName        = "/flowmesh.v1.QueueService/Enqueue"
	QueueService_Reserve_FullMethodName        = "/flowmesh.v1.QueueService/Reserve"
	QueueService_Receive_FullMethodName        = "/flowmesh.v1.QueueService/Receive"
	QueueService_ACK_FullMethodName            = "/flowmesh.v1.QueueService/ACK"
	QueueService_NACK_FullMethodName           = "/flowmesh.v1.QueueService/NACK"
	QueueService_GetQueueStats_FullMethodName  = "/flowmesh.v1.QueueService/GetQueueStats"
	QueueService_SetRetryPolicy_FullMethodName = "/flowmesh.v1.QueueService/SetRetryPolicy"
	QueueService_GetRetryPolicy_FullMethodName = "/flowmesh.v1.QueueService/GetRetryPolicy"
	QueueService_ListDLQJobs_FullMethodName    = "/flowmesh.v1.QueueService/ListDLQJobs"
	QueueService_ReplayDLQJob_FullMethodName   = "/flowmesh.v1.QueueService/ReplayDLQJob"
)

// QueueServiceClient is the client API for QueueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// QueueService provides operations for working with queues
type QueueServiceClient interface {
	// Enqueue enqueues a job to a queue and returns job ID and sequence number
	Enqueue(ctx context.Context, in *EnqueueRequest, opts ...grpc.CallOption) (*EnqueueResponse, error)
	// Reserve reserves a single job from the queue with visibility timeout
	Reserve(ctx context.Context, in *ReserveRequest, opts ...grpc.CallOption) (*ReserveResponse, error)
	// Receive receives multiple jobs from the queue (batch receive)
	Receive(ctx context.Context, in *ReceiveRequest, opts ...grpc.CallOption) (*ReceiveResponse, error)
	// ACK acknowledges completion of a job
	ACK(ctx context.Context, in *ACKRequest, opts ...grpc.CallOption) (*ACKResponse, error)
	// NACK negatively acknowledges a job (requeue with backoff)
	NACK(ctx context.Context, in *NACKRequest, opts ...grpc.CallOption) (*NACKResponse, error)
	// GetQueueStats retrieves queue statistics (depth, in-flight, age, etc.)
	GetQueueStats(ctx context.Context, in *GetQueueStatsRequest, opts ...grpc.CallOption) (*GetQueueStatsResponse, error)
	// SetRetryPolicy sets the retry policy for a queue
	SetRetryPolicy(ctx context.Context, in *SetRetryPolicyRequest, opts ...grpc.CallOption) (*SetRetryPolicyResponse, error)
	// GetRetryPolicy gets the retry policy for a queue
	GetRetryPolicy(ctx context.Context, in *GetRetryPolicyRequest, opts ...grpc.CallOption) (*GetRetryPolicyResponse, error)
	// ListDLQJobs lists jobs in the dead-letter queue
	ListDLQJobs(ctx context.Context, in *ListDLQJobsRequest, opts ...grpc.CallOption) (*ListDLQJobsResponse, error)
	// ReplayDLQJob replays a job from DLQ back to the main queue
	ReplayDLQJob(ctx context.Context, in *ReplayDLQJobRequest, opts ...grpc.CallOption) (*ReplayDLQJobResponse, error)
}

type queueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQueueServiceClient(cc grpc.ClientConnInterface) QueueServiceClient {
	return &queueServiceClient{cc}
}

func (c *queueServiceClient) Enqueue(ctx context.Context, in *EnqueueRequest, opts ...grpc.CallOption) (*EnqueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnqueueResponse)
	err := c.cc.Invoke(ctx, QueueService_Enqueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) Reserve(ctx context.Context, in *ReserveRequest, opts ...grpc.CallOption) (*ReserveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReserveResponse)
	err := c.cc.Invoke(ctx, QueueService_Reserve_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) Receive(ctx context.Context, in *ReceiveRequest, opts ...grpc.CallOption) (*ReceiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReceiveResponse)
	err := c.cc.Invoke(ctx, QueueService_Receive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) ACK(ctx context.Context, in *ACKRequest, opts ...grpc.CallOption) (*ACKResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ACKResponse)
	err := c.cc.Invoke(ctx, QueueService_ACK_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) NACK(ctx context.Context, in *NACKRequest, opts ...grpc.CallOption) (*NACKResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NACKResponse)
	err := c.cc.Invoke(ctx, QueueService_NACK_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetQueueStats(ctx context.Context, in *GetQueueStatsRequest, opts ...grpc.CallOption) (*GetQueueStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQueueStatsResponse)
	err := c.cc.Invoke(ctx, QueueService_GetQueueStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) SetRetryPolicy(ctx context.Context, in *SetRetryPolicyRequest, opts ...grpc.CallOption) (*SetRetryPolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetRetryPolicyResponse)
	err := c.cc.Invoke(ctx, QueueService_SetRetryPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetRetryPolicy(ctx context.Context, in *GetRetryPolicyRequest, opts ...grpc.CallOption) (*GetRetryPolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRetryPolicyResponse)
	err := c.cc.Invoke(ctx, QueueService_GetRetryPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) ListDLQJobs(ctx context.Context, in *ListDLQJobsRequest, opts ...grpc.CallOption) (*ListDLQJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDLQJobsResponse)
	err := c.cc.Invoke(ctx, QueueService_ListDLQJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) ReplayDLQJob(ctx context.Context, in *ReplayDLQJobRequest, opts ...grpc.CallOption) (*ReplayDLQJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplayDLQJobResponse)
	err := c.cc.Invoke(ctx, QueueService_ReplayDLQJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueueServiceServer is the server API for QueueService service.
// All implementations must embed UnimplementedQueueServiceServer
// for forward compatibility.
//
// QueueService provides operations for working with queues
type QueueServiceServer interface {
	// Enqueue enqueues a job to a queue and returns job ID and sequence number
	Enqueue(context.Context, *EnqueueRequest) (*EnqueueResponse, error)
	// Reserve reserves a single job from the queue with visibility timeout
	Reserve(context.Context, *ReserveRequest) (*ReserveResponse, error)
	// Receive receives multiple jobs from the queue (batch receive)
	Receive(context.Context, *ReceiveRequest) (*ReceiveResponse, error)
	// ACK acknowledges completion of a job
	ACK(context.Context, *ACKRequest) (*ACKResponse, error)
	// NACK negatively acknowledges a job (requeue with backoff)
	NACK(context.Context, *NACKRequest) (*NACKResponse, error)
	// GetQueueStats retrieves queue statistics (depth, in-flight, age, etc.)
	GetQueueStats(context.Context, *GetQueueStatsRequest) (*GetQueueStatsResponse, error)
	// SetRetryPolicy sets the retry policy for a queue
	SetRetryPolicy(context.Context, *SetRetryPolicyRequest) (*SetRetryPolicyResponse, error)
	// GetRetryPolicy gets the retry policy for a queue
	GetRetryPolicy(context.Context, *GetRetryPolicyRequest) (*GetRetryPolicyResponse, error)
	// ListDLQJobs lists jobs in the dead-letter queue
	ListDLQJobs(context.Context, *ListDLQJobsRequest) (*ListDLQJobsResponse, error)
	// ReplayDLQJob replays a job from DLQ back to the main queue
	ReplayDLQJob(context.Context, *ReplayDLQJobRequest) (*ReplayDLQJobResponse, error)
	mustEmbedUnimplementedQueueServiceServer()
}

// UnimplementedQueueServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQueueServiceServer struct{}

func (UnimplementedQueueServiceServer) Enqueue(context.Context, *EnqueueRequest) (*EnqueueResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Enqueue not implemented")
}
func (UnimplementedQueueServiceServer) Reserve(context.Context, *ReserveRequest) (*ReserveResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Reserve not implemented")
}
func (UnimplementedQueueServiceServer) Receive(context.Context, *ReceiveRequest) (*ReceiveResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Receive not implemented")
}
func (UnimplementedQueueServiceServer) ACK(context.Context, *ACKRequest) (*ACKResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ACK not implemented")
}
func (UnimplementedQueueServiceServer) NACK(context.Context, *NACKRequest) (*NACKResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NACK not implemented")
}
func (UnimplementedQueueServiceServer) GetQueueStats(context.Context, *GetQueueStatsRequest) (*GetQueueStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetQueueStats not implemented")
}
func (UnimplementedQueueServiceServer) SetRetryPolicy(context.Context, *SetRetryPolicyRequest) (*SetRetryPolicyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetRetryPolicy not implemented")
}
func (UnimplementedQueueServiceServer) GetRetryPolicy(context.Context, *GetRetryPolicyRequest) (*GetRetryPolicyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRetryPolicy not implemented")
}
func (UnimplementedQueueServiceServer) ListDLQJobs(context.Context, *ListDLQJobsRequest) (*ListDLQJobsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDLQJobs not implemented")
}
func (UnimplementedQueueServiceServer) ReplayDLQJob(context.Context, *ReplayDLQJobRequest) (*ReplayDLQJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReplayDLQJob not implemented")
}
func (UnimplementedQueueServiceServer) mustEmbedUnimplementedQueueServiceServer() {}
func (UnimplementedQueueServiceServer) testEmbeddedByValue()                      {}

// UnsafeQueueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueueServiceServer will
// result in compilation errors.
type UnsafeQueueServiceServer interface {
	mustEmbedUnimplementedQueueServiceServer()
}

func RegisterQueueServiceServer(s grpc.ServiceRegistrar, srv QueueServiceServer) {
	// If the following call panics, it indicates UnimplementedQueueServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&QueueService_ServiceDesc, srv)
}

func _QueueService_Enqueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).Enqueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_Enqueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).Enqueue(ctx, req.(*EnqueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_Reserve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReserveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).Reserve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_Reserve_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).Reserve(ctx, req.(*ReserveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_Receive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).Receive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_Receive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).Receive(ctx, req.(*ReceiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_ACK_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ACKRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).ACK(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_ACK_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).ACK(ctx, req.(*ACKRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_NACK_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NACKRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).NACK(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_NACK_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).NACK(ctx, req.(*NACKRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetQueueStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQueueStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetQueueStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_GetQueueStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetQueueStats(ctx, req.(*GetQueueStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_SetRetryPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRetryPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).SetRetryPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_SetRetryPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).SetRetryPolicy(ctx, req.(*SetRetryPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetRetryPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRetryPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetRetryPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_GetRetryPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetRetryPolicy(ctx, req.(*GetRetryPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_ListDLQJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDLQJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).ListDLQJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_ListDLQJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).ListDLQJobs(ctx, req.(*ListDLQJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_ReplayDLQJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplayDLQJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).ReplayDLQJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_ReplayDLQJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).ReplayDLQJob(ctx, req.(*ReplayDLQJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// QueueService_ServiceDesc is the grpc.ServiceDesc for QueueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "flowmesh.v1.QueueService",
	HandlerType: (*QueueServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Enqueue",
			Handler:    _QueueService_Enqueue_Handler,
		},
		{
			MethodName: "Reserve",
			Handler:    _QueueService_Reserve_Handler,
		},
		{
			MethodName: "Receive",
			Handler:    _QueueService_Receive_Handler,
		},
		{
			MethodName: "ACK",
			Handler:    _QueueService_ACK_Handler,
		},
		{
			MethodName: "NACK",
			Handler:    _QueueService_NACK_Handler,
		},
		{
			MethodName: "GetQueueStats",
			Handler:    _QueueService_GetQueueStats_Handler,
		},
		{
			MethodName: "SetRetryPolicy",
			Handler:    _QueueService_SetRetryPolicy_Handler,
		},
		{
			MethodName: "GetRetryPolicy",
			Handler:    _QueueService_GetRetryPolicy_Handler,
		},
		{
			MethodName: "ListDLQJobs",
			Handler:    _QueueService_ListDLQJobs_Handler,
		},
		{
			MethodName: "ReplayDLQJob",
			Handler:    _QueueService_ReplayDLQJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "flowmesh.proto",
}

const (
	KVService_Set_FullMethodName      = "/flowmesh.v1.KVService/Set"
	KVService_Get_FullMethodName      = "/flowmesh.v1.KVService/Get"
	KVService_Delete_FullMethodName   = "/flowmesh.v1.KVService/Delete"
	KVService_Exists_FullMethodName   = "/flowmesh.v1.KVService/Exists"
	KVService_ListKeys_FullMethodName = "/flowmesh.v1.KVService/ListKeys"
)

// KVServiceClient is the client API for KVService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// KVService provides operations for working with KV stores
type KVServiceClient interface {
	// Set sets a key-value pair with optional TTL
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
	// Get retrieves a value by key
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Delete deletes a key
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// Exists checks if a key exists
	Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error)
	// ListKeys lists all keys, optionally filtered by prefix
	ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error)
}

type kVServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKVServiceClient(cc grpc.ClientConnInterface) KVServiceClient {
	return &kVServiceClient{cc}
}

func (c *kVServiceClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, KVService_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, KVService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, KVService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVServiceClient) Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExistsResponse)
	err := c.cc.Invoke(ctx, KVService_Exists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVServiceClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKeysResponse)
	err := c.cc.Invoke(ctx, KVService_ListKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KVServiceServer is the server API for KVService service.
// All implementations must embed UnimplementedKVServiceServer
// for forward compatibility.
//
// KVService provides operations for working with KV stores
type KVServiceServer interface {
	// Set sets a key-value pair with optional TTL
	Set(context.Context, *SetRequest) (*SetResponse, error)
	// Get retrieves a value by key
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// Delete deletes a key
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// Exists checks if a key exists
	Exists(context.Context, *ExistsRequest) (*ExistsResponse, error)
	// ListKeys lists all keys, optionally filtered by prefix
	ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error)
	mustEmbedUnimplementedKVServiceServer()
}

// UnimplementedKVServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKVServiceServer struct{}

func (UnimplementedKVServiceServer) Set(context.Context, *SetRequest) (*SetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedKVServiceServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedKVServiceServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedKVServiceServer) Exists(context.Context, *ExistsRequest) (*ExistsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedKVServiceServer) ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListKeys not implemented")
}
func (UnimplementedKVServiceServer) mustEmbedUnimplementedKVServiceServer() {}
func (UnimplementedKVServiceServer) testEmbeddedByValue()                   {}

// UnsafeKVServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KVServiceServer will
// result in compilation errors.
type UnsafeKVServiceServer interface {
	mustEmbedUnimplementedKVServiceServer()
}

func RegisterKVServiceServer(s grpc.ServiceRegistrar, srv KVServiceServer) {
	// If the following call panics, it indicates UnimplementedKVServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KVService_ServiceDesc, srv)
}

func _KVService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVService_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServiceServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServiceServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVService_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServiceServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVService_Exists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServiceServer).Exists(ctx, req.(*ExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVService_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServiceServer).ListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVService_ListKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServiceServer).ListKeys(ctx, req.(*ListKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KVService_ServiceDesc is the grpc.ServiceDesc for KVService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KVService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "flowmesh.v1.KVService",
	HandlerType: (*KVServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _KVService_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _KVService_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _KVService_Delete_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _KVService_Exists_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _KVService_ListKeys_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "flowmesh.proto",
}

const (
	SchemaService_RegisterSchema_FullMethodName    = "/flowmesh.v1.SchemaService/RegisterSchema"
	SchemaService_GetSchema_FullMethodName         = "/flowmesh.v1.SchemaService/GetSchema"
	SchemaService_ListSchemas_FullMethodName       = "/flowmesh.v1.SchemaService/ListSchemas"
	SchemaService_DeleteSchema_FullMethodName      = "/flowmesh.v1.SchemaService/DeleteSchema"
	SchemaService_SetResourceSchema_FullMethodName = "/flowmesh.v1.SchemaService/SetResourceSchema"
)

// SchemaServiceClient is the client API for SchemaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SchemaService provides operations for working with schemas
type SchemaServiceClient interface {
	// RegisterSchema registers a new schema version
	RegisterSchema(ctx context.Context, in *RegisterSchemaRequest, opts ...grpc.CallOption) (*RegisterSchemaResponse, error)
	// GetSchema retrieves a schema by ID and version
	GetSchema(ctx context.Context, in *GetSchemaRequest, opts ...grpc.CallOption) (*GetSchemaResponse, error)
	// ListSchemas lists all schemas, optionally filtered by schema ID
	ListSchemas(ctx context.Context, in *ListSchemasRequest, opts ...grpc.CallOption) (*ListSchemasResponse, error)
	// DeleteSchema deletes a schema version
	DeleteSchema(ctx context.Context, in *DeleteSchemaRequest, opts ...grpc.CallOption) (*DeleteSchemaResponse, error)
	// SetResourceSchema attaches a schema to a resource (stream/queue)
	SetResourceSchema(ctx context.Context, in *SetResourceSchemaRequest, opts ...grpc.CallOption) (*SetResourceSchemaResponse, error)
}

type schemaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSchemaServiceClient(cc grpc.ClientConnInterface) SchemaServiceClient {
	return &schemaServiceClient{cc}
}

func (c *schemaServiceClient) RegisterSchema(ctx context.Context, in *RegisterSchemaRequest, opts ...grpc.CallOption) (*RegisterSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterSchemaResponse)
	err := c.cc.Invoke(ctx, SchemaService_RegisterSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaServiceClient) GetSchema(ctx context.Context, in *GetSchemaRequest, opts ...grpc.CallOption) (*GetSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSchemaResponse)
	err := c.cc.Invoke(ctx, SchemaService_GetSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaServiceClient) ListSchemas(ctx context.Context, in *ListSchemasRequest, opts ...grpc.CallOption) (*ListSchemasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSchemasResponse)
	err := c.cc.Invoke(ctx, SchemaService_ListSchemas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaServiceClient) DeleteSchema(ctx context.Context, in *DeleteSchemaRequest, opts ...grpc.CallOption) (*DeleteSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSchemaResponse)
	err := c.cc.Invoke(ctx, SchemaService_DeleteSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaServiceClient) SetResourceSchema(ctx context.Context, in *SetResourceSchemaRequest, opts ...grpc.CallOption) (*SetResourceSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResourceSchemaResponse)
	err := c.cc.Invoke(ctx, SchemaService_SetResourceSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchemaServiceServer is the server API for SchemaService service.
// All implementations must embed UnimplementedSchemaServiceServer
// for forward compatibility.
//
// SchemaService provides operations for working with schemas
type SchemaServiceServer interface {
	// RegisterSchema registers a new schema version
	RegisterSchema(context.Context, *RegisterSchemaRequest) (*RegisterSchemaResponse, error)
	// GetSchema retrieves a schema by ID and version
	GetSchema(context.Context, *GetSchemaRequest) (*GetSchemaResponse, error)
	// ListSchemas lists all schemas, optionally filtered by schema ID
	ListSchemas(context.Context, *ListSchemasRequest) (*ListSchemasResponse, error)
	// DeleteSchema deletes a schema version
	DeleteSchema(context.Context, *DeleteSchemaRequest) (*DeleteSchemaResponse, error)
	// SetResourceSchema attaches a schema to a resource (stream/queue)
	SetResourceSchema(context.Context, *SetResourceSchemaRequest) (*SetResourceSchemaResponse, error)
	mustEmbedUnimplementedSchemaServiceServer()
}

// UnimplementedSchemaServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSchemaServiceServer struct{}

func (UnimplementedSchemaServiceServer) RegisterSchema(context.Context, *RegisterSchemaRequest) (*RegisterSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterSchema not implemented")
}
func (UnimplementedSchemaServiceServer) GetSchema(context.Context, *GetSchemaRequest) (*GetSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSchema not implemented")
}
func (UnimplementedSchemaServiceServer) ListSchemas(context.Context, *ListSchemasRequest) (*ListSchemasResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSchemas not implemented")
}
func (UnimplementedSchemaServiceServer) DeleteSchema(context.Context, *DeleteSchemaRequest) (*DeleteSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSchema not implemented")
}
func (UnimplementedSchemaServiceServer) SetResourceSchema(context.Context, *SetResourceSchemaRequest) (*SetResourceSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetResourceSchema not implemented")
}
func (UnimplementedSchemaServiceServer) mustEmbedUnimplementedSchemaServiceServer() {}
func (UnimplementedSchemaServiceServer) testEmbeddedByValue()                       {}

// UnsafeSchemaServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SchemaServiceServer will
// result in compilation errors.
type UnsafeSchemaServiceServer interface {
	mustEmbedUnimplementedSchemaServiceServer()
}

func RegisterSchemaServiceServer(s grpc.ServiceRegistrar, srv SchemaServiceServer) {
	// If the following call panics, it indicates UnimplementedSchemaServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SchemaService_ServiceDesc, srv)
}

func _SchemaService_RegisterSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaServiceServer).RegisterSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaService_RegisterSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaServiceServer).RegisterSchema(ctx, req.(*RegisterSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaService_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaServiceServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaService_GetSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaServiceServer).GetSchema(ctx, req.(*GetSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaService_ListSchemas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSchemasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaServiceServer).ListSchemas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaService_ListSchemas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaServiceServer).ListSchemas(ctx, req.(*ListSchemasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaService_DeleteSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaServiceServer).DeleteSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaService_DeleteSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaServiceServer).DeleteSchema(ctx, req.(*DeleteSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaService_SetResourceSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetResourceSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaServiceServer).SetResourceSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaService_SetResourceSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaServiceServer).SetResourceSchema(ctx, req.(*SetResourceSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SchemaService_ServiceDesc is the grpc.ServiceDesc for SchemaService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SchemaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "flowmesh.v1.SchemaService",
	HandlerType: (*SchemaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterSchema",
			Handler:    _SchemaService_RegisterSchema_Handler,
		},
		{
			MethodName: "GetSchema",
			Handler:    _SchemaService_GetSchema_Handler,
		},
		{
			MethodName: "ListSchemas",
			Handler:    _SchemaService_ListSchemas_Handler,
		},
		{
			MethodName: "DeleteSchema",
			Handler:    _SchemaService_DeleteSchema_Handler,
		},
		{
			MethodName: "SetResourceSchema",
			Handler:    _SchemaService_SetResourceSchema_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "flowmesh.proto",
}

const (
	ReplayService_CreateReplaySession_FullMethodName = "/flowmesh.v1.ReplayService/CreateReplaySession"
	ReplayService_GetReplaySession_FullMethodName    = "/flowmesh.v1.ReplayService/GetReplaySession"
	ReplayService_ListReplaySessions_FullMethodName  = "/flowmesh.v1.ReplayService/ListReplaySessions"
	ReplayService_StartReplay_FullMethodName         = "/flowmesh.v1.ReplayService/StartReplay"
	ReplayService_PauseReplay_FullMethodName         = "/flowmesh.v1.ReplayService/PauseReplay"
	ReplayService_ResumeReplay_FullMethodName        = "/flowmesh.v1.ReplayService/ResumeReplay"
	ReplayService_StopReplay_FullMethodName          = "/flowmesh.v1.ReplayService/StopReplay"
	ReplayService_DeleteReplaySession_FullMethodName = "/flowmesh.v1.ReplayService/DeleteReplaySession"
)

// ReplayServiceClient is the client API for ReplayService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ReplayService provides operations for replay sessions
type ReplayServiceClient interface {
	// CreateReplaySession creates a new replay session
	CreateReplaySession(ctx context.Context, in *CreateReplaySessionRequest, opts ...grpc.CallOption) (*CreateReplaySessionResponse, error)
	// GetReplaySession retrieves a replay session by ID
	GetReplaySession(ctx context.Context, in *GetReplaySessionRequest, opts ...grpc.CallOption) (*GetReplaySessionResponse, error)
	// ListReplaySessions lists all replay sessions, optionally filtered by stream
	ListReplaySessions(ctx context.Context, in *ListReplaySessionsRequest, opts ...grpc.CallOption) (*ListReplaySessionsResponse, error)
	// StartReplay starts replaying messages for a session
	StartReplay(ctx context.Context, in *StartReplayRequest, opts ...grpc.CallOption) (*StartReplayResponse, error)
	// PauseReplay pauses an active replay session
	PauseReplay(ctx context.Context, in *PauseReplayRequest, opts ...grpc.CallOption) (*PauseReplayResponse, error)
	// ResumeReplay resumes a paused replay session
	ResumeReplay(ctx context.Context, in *ResumeReplayRequest, opts ...grpc.CallOption) (*ResumeReplayResponse, error)
	// StopReplay stops an active replay session
	StopReplay(ctx context.Context, in *StopReplayRequest, opts ...grpc.CallOption) (*StopReplayResponse, error)
	// DeleteReplaySession deletes a replay session
	DeleteReplaySession(ctx context.Context, in *DeleteReplaySessionRequest, opts ...grpc.CallOption) (*DeleteReplaySessionResponse, error)
}

type replayServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReplayServiceClient(cc grpc.ClientConnInterface) ReplayServiceClient {
	return &replayServiceClient{cc}
}

func (c *replayServiceClient) CreateReplaySession(ctx context.Context, in *CreateReplaySessionRequest, opts ...grpc.CallOption) (*CreateReplaySessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateReplaySessionResponse)
	err := c.cc.Invoke(ctx, ReplayService_CreateReplaySession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replayServiceClient) GetReplaySession(ctx context.Context, in *GetReplaySessionRequest, opts ...grpc.CallOption) (*GetReplaySessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReplaySessionResponse)
	err := c.cc.Invoke(ctx, ReplayService_GetReplaySession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replayServiceClient) ListReplaySessions(ctx context.Context, in *ListReplaySessionsRequest, opts ...grpc.CallOption) (*ListReplaySessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReplaySessionsResponse)
	err := c.cc.Invoke(ctx, ReplayService_ListReplaySessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replayServiceClient) StartReplay(ctx context.Context, in *StartReplayRequest, opts ...grpc.CallOption) (*StartReplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartReplayResponse)
	err := c.cc.Invoke(ctx, ReplayService_StartReplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replayServiceClient) PauseReplay(ctx context.Context, in *PauseReplayRequest, opts ...grpc.CallOption) (*PauseReplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseReplayResponse)
	err := c.cc.Invoke(ctx, ReplayService_PauseReplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replayServiceClient) ResumeReplay(ctx context.Context, in *ResumeReplayRequest, opts ...grpc.CallOption) (*ResumeReplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResumeReplayResponse)
	err := c.cc.Invoke(ctx, ReplayService_ResumeReplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replayServiceClient) StopReplay(ctx context.Context, in *StopReplayRequest, opts ...grpc.CallOption) (*StopReplayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopReplayResponse)
	err := c.cc.Invoke(ctx, ReplayService_StopReplay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replayServiceClient) DeleteReplaySession(ctx context.Context, in *DeleteReplaySessionRequest, opts ...grpc.CallOption) (*DeleteReplaySessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteReplaySessionResponse)
	err := c.cc.Invoke(ctx, ReplayService_DeleteReplaySession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplayServiceServer is the server API for ReplayService service.
// All implementations must embed UnimplementedReplayServiceServer
// for forward compatibility.
//
// ReplayService provides operations for replay sessions
type ReplayServiceServer interface {
	// CreateReplaySession creates a new replay session
	CreateReplaySession(context.Context, *CreateReplaySessionRequest) (*CreateReplaySessionResponse, error)
	// GetReplaySession retrieves a replay session by ID
	GetReplaySession(context.Context, *GetReplaySessionRequest) (*GetReplaySessionResponse, error)
	// ListReplaySessions lists all replay sessions, optionally filtered by stream
	ListReplaySessions(context.Context, *ListReplaySessionsRequest) (*ListReplaySessionsResponse, error)
	// StartReplay starts replaying messages for a session
	StartReplay(context.Context, *StartReplayRequest) (*StartReplayResponse, error)
	// PauseReplay pauses an active replay session
	PauseReplay(context.Context, *PauseReplayRequest) (*PauseReplayResponse, error)
	// ResumeReplay resumes a paused replay session
	ResumeReplay(context.Context, *ResumeReplayRequest) (*ResumeReplayResponse, error)
	// StopReplay stops an active replay session
	StopReplay(context.Context, *StopReplayRequest) (*StopReplayResponse, error)
	// DeleteReplaySession deletes a replay session
	DeleteReplaySession(context.Context, *DeleteReplaySessionRequest) (*DeleteReplaySessionResponse, error)
	mustEmbedUnimplementedReplayServiceServer()
}

// UnimplementedReplayServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReplayServiceServer struct{}

func (UnimplementedReplayServiceServer) CreateReplaySession(context.Context, *CreateReplaySessionRequest) (*CreateReplaySessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateReplaySession not implemented")
}
func (UnimplementedReplayServiceServer) GetReplaySession(context.Context, *GetReplaySessionRequest) (*GetReplaySessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetReplaySession not implemented")
}
func (UnimplementedReplayServiceServer) ListReplaySessions(context.Context, *ListReplaySessionsRequest) (*ListReplaySessionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListReplaySessions not implemented")
}
func (UnimplementedReplayServiceServer) StartReplay(context.Context, *StartReplayRequest) (*StartReplayResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartReplay not implemented")
}
func (UnimplementedReplayServiceServer) PauseReplay(context.Context, *PauseReplayRequest) (*PauseReplayResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PauseReplay not implemented")
}
func (UnimplementedReplayServiceServer) ResumeReplay(context.Context, *ResumeReplayRequest) (*ResumeReplayResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResumeReplay not implemented")
}
func (UnimplementedReplayServiceServer) StopReplay(context.Context, *StopReplayRequest) (*StopReplayResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopReplay not implemented")
}
func (UnimplementedReplayServiceServer) DeleteReplaySession(context.Context, *DeleteReplaySessionRequest) (*DeleteReplaySessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteReplaySession not implemented")
}
func (UnimplementedReplayServiceServer) mustEmbedUnimplementedReplayServiceServer() {}
func (UnimplementedReplayServiceServer) testEmbeddedByValue()                       {}

// UnsafeReplayServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplayServiceServer will
// result in compilation errors.
type UnsafeReplayServiceServer interface {
	mustEmbedUnimplementedReplayServiceServer()
}

func RegisterReplayServiceServer(s grpc.ServiceRegistrar, srv ReplayServiceServer) {
	// If the following call panics, it indicates UnimplementedReplayServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReplayService_ServiceDesc, srv)
}

func _ReplayService_CreateReplaySession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReplaySessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplayServiceServer).CreateReplaySession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplayService_CreateReplaySession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplayServiceServer).CreateReplaySession(ctx, req.(*CreateReplaySessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplayService_GetReplaySession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReplaySessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplayServiceServer).GetReplaySession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplayService_GetReplaySession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplayServiceServer).GetReplaySession(ctx, req.(*GetReplaySessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplayService_ListReplaySessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReplaySessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplayServiceServer).ListReplaySessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplayService_ListReplaySessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplayServiceServer).ListReplaySessions(ctx, req.(*ListReplaySessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplayService_StartReplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartReplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplayServiceServer).StartReplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplayService_StartReplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplayServiceServer).StartReplay(ctx, req.(*StartReplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplayService_PauseReplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseReplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplayServiceServer).PauseReplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplayService_PauseReplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplayServiceServer).PauseReplay(ctx, req.(*PauseReplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplayService_ResumeReplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeReplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplayServiceServer).ResumeReplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplayService_ResumeReplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplayServiceServer).ResumeReplay(ctx, req.(*ResumeReplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplayService_StopReplay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopReplayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplayServiceServer).StopReplay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplayService_StopReplay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplayServiceServer).StopReplay(ctx, req.(*StopReplayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplayService_DeleteReplaySession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReplaySessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplayServiceServer).DeleteReplaySession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplayService_DeleteReplaySession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplayServiceServer).DeleteReplaySession(ctx, req.(*DeleteReplaySessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReplayService_ServiceDesc is the grpc.ServiceDesc for ReplayService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReplayService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "flowmesh.v1.ReplayService",
	HandlerType: (*ReplayServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateReplaySession",
			Handler:    _ReplayService_CreateReplaySession_Handler,
		},
		{
			MethodName: "GetReplaySession",
			Handler:    _ReplayService_GetReplaySession_Handler,
		},
		{
			MethodName: "ListReplaySessions",
			Handler:    _ReplayService_ListReplaySessions_Handler,
		},
		{
			MethodName: "StartReplay",
			Handler:    _ReplayService_StartReplay_Handler,
		},
		{
			MethodName: "PauseReplay",
			Handler:    _ReplayService_PauseReplay_Handler,
		},
		{
			MethodName: "ResumeReplay",
			Handler:    _ReplayService_ResumeReplay_Handler,
		},
		{
			MethodName: "StopReplay",
			Handler:    _ReplayService_StopReplay_Handler,
		},
		{
			MethodName: "DeleteReplaySession",
			Handler:    _ReplayService_DeleteReplaySession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "flowmesh.proto",
}
